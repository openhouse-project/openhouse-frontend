See our ETHGlobal HackMoney demo here: https://youtu.be/cUkIslbHW-Y

# Definitions

"Synchronous Social Media" is a form of social communication, where interactions occur live and in real-time, between actors. Zoom is a well-known example of a platform for such communication, generating a network of ephemeral and lasting "grass-roots" connections between individuals all over the planet. Clubhouse is another example, with users being invited by existing users.

"Community Moderation" is where a shared service is moderated by a community consisting of multiple actors in a system. Community Moderation differs from traditional moderation, whereby a single actor typically has ultimate power to exclude another single actor from a system.

# Abstract

With the rise of "remote", many of us are spending more time online. Whether learning, communicating, building or transacting, our work lives have migrated towards our computers and smartphones.

When interacting with others, we often use:

- Synchronous communication (live, real time, e.g. a telephone call, a Zoom video-chat, a Clubhouse room, a Twitter Space), and

- Asynchronous communication (not requiring an immediate reaction, e.g. an email, a Telegram text-chat, a Tweet).

Synchronous communication is typically "higher-bandwidth", while Asynchronous tends to be "more transparent".

Many such platforms for communication still rely on centralised infrastructure platforms to operate, whose owner configure the logic to decide who is included, and who is excluded.

Meanwhile, traditional Asynchronous Social Media platforms, like Facebook, YouTube and Twitter, struggle to effectively moderate content being shared on their platforms. Such platforms face regulatory risk as well as accusations of censorship and copyright infringement.

Against this global digital backdrop, this project is developing online communications software, to help connect humans with each other online, in spaces governed by humans, for humans. 

The objective is to cultivate open digital spaces, where humans can come together and share with each other in real time, safe in the knowledge that they are all collectively responsible for what can happen inside.

Together, we can work towards making Social Media a safe and engaging place to be...

# How it's made
Openhouse is building open-source software to power decentralized synchronous social networks. Openhouse’s hackathon project demonstrates the ability to authenticate, name, pay, and govern within a video chat room site all using the Ethereum blockchain.

# Implementation 

Openhouse is built on the following open-source technologies:

* Svelte-kit powers the frontend UI and backend authorization server.
* web3.js  is used to allow the user to connect their wallet to the app, and call our smart contracts
* Jitsi runs on a separate server to demonstrate Openhouse’s ability to bring on-chain authentication to existing platforms.
* JSON Web Tokens are used for authentication with Jitsi (and could be used with other web 2 tools). Our lightweight auth server verifies on-chain data (your wallet’s address, through a signed message) and issues a JWT which can be accepted by web 2 applications, like Jitsi.
* Solidity was used to write the Openhouse smart contract, which stores information on chain, and the ParticipantAccessToken contract which specifies a custom ERC721 token that is deployed for every room on Openhouse to control access and allow for decentralized access management.

And the following third-party technologies:

* Polygon - the application is deployed to the MATIC network to take advantage of its speed and low transaction fees, given the number of transactions that are used by the Openhouse protocol
* Rarible - the Rarible API is used to fetch a user’s NFTs, which are made available as video backgrounds
* ENS - the user’s ENS name is fetched to be displayed across Openhouse’s UI instead of the wallet address
* Protocol Labs - for storing image data

## Running the code

First, start Redis using docker. Redis is used to store the nonce generated by the auth server component.
```
docker-compose up
```

Next, install your node dependencies (our team uses pnpm):

```
pnpm install
```

Finally, run the project locally with

```
pnpm run dev
```

You'll need to set environment variables in a `.env` file. Copy the `dev.env` file, and populate it with values that make sense for you. The Jitsi fields will be determined by your Jitsi configuration - see the [Self-Hosting Guide](https://jitsi.github.io/handbook/docs/devops-guide/devops-guide-docker), paying particular attention to the section on JWT authentication. Your secret will need to be the same in Jitsi, and in your `.env` file, and your app ID will need to match as well, since it is included as a claim in the JWT body.

To deploy, run `pnpm build` which  generates a `build/` folder that can be run using `node build`.
